##关于引用型的三言两语
对于应用型变量应记住的几句话。
* 引用型**变量**只能有一种类型，一旦申明，终生不变（终生是针对其生命周期）——可确定性
* 引用型变量的类型用来规定它所能引用的对象类型构成的集合（声明类及其隶属子类），以及通过该变量所能调用的资源集合（实例变量、实例方法、类变量、类方法都可看作资源）
* 引用型变量在RunningTime期具有可变性，在所能引用的对象类型集合范围内可任意变动——不稳定性
* 引用型变量在RunningTime期的不稳定性，是Java多态的基础，也是可以用来解释很多Puzzle的工具。


##Overriding应该记住的几句话
* 重写只针对父类与子类的同名实例方法间的关系，不针对实例变量及类成员
* 重写的前提是继承，对子类不可见的方法（private、不同包default修饰的）不会被继承，也无谈重写
* 分析重写时，不妨先假设子类无条件地继承所以父类可继承的实例方法（虽然Java未必这样处理）
* 被继承下来的方法和同名但成员标识不同的子类方法不是重写关系，而是重载关系（详见第1条）
* 从父类继承的final方法不可重写；抽象方法、接口方法必须重写；其他方法可选重写
* 一旦子类的代码中，包含的实例方法满足一下标准，重写就事实发生：

> 子类方法的参数列表必须和父类方法的精确匹配，换句话说就是成员标识相同
> 子~~~~~~~~返回类型必须和父~~~的同类或隶属子类
> 子~~~~~~~~访问级别等于或不严格于父~~~
> 子~~~~~~~~抛出异常在类型上必须与父~~~同类或隶属子类；如果抛错类型是RunningTime Exception怎不受约束
> 子~~~~~~~~抛出异常在个数上等于或少于父~~~，甚至不抛错

* 对final方法重写compiler报错；对abstract没有正确的重写compiler报错；对方法重写但不达标的这种作死节奏，同名但标识不同，不构成重写，重载发生；同名且标识相同，compiler报错。
